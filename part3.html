<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YCY17GV3DB');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen" charset="utf-8">

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
    crossorigin="anonymous"
  ></script>
  <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>
      
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-19048260-11", "auto");
  ga("send", "pageview");

  hljs.highlightAll();
</script>
</head>
<body data-bs-spy="scroll" data-target="#toc">
  <div class="container">
    <div class="row">
      <div class="col-sm-3">
        <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
      </div>
      <div class="col-sm-9">


<h1 id="-esc190-lecture-notes">ESC190 Lecture Notes: Part 3<br>Advanced Data Structures and Algorithms</h1>
    <p>See all lecture notes <a href="../">here</a>.</p>
    </p>
<h1 id="L22">L22: Stacks and Queues</h1>
<h2 id="L22-stack">Stack ADT</h2>
<div class="alert alert-success" role="alert"><br>
    A <b>stack</b> is a collection of elements with the operations <code>push</code> and <code>pop</code>
    <ul>
        <li><code>push</code> inserts the elements into the collection</li>
        <li><code>pop</code> removes the most <i>recently added element that's not yet removed and returns it</i></li>
    </ul>
</div>
Intuitively, we can think of this as a stack of blocks. We can only add blocks to the top of this stack and remove it from the top. This is known as LIFO (last in first out). If we start with an empty list <code>[ ]</code> then run the following commands, we have:
<ol>
    <li><code>push(1)</code></li>
    <li><code>push(50)</code></li>
    <li><code>pop()</code> (returns 50)</li>
    <li><code>push(100)</code></li>
    <li><code>pop()</code> (returns 100)</li>
    <li><code>pop()</code> (returns 1)</li>
</ol>
Note: Note that our "stack of blocks" analogy is an analogy of how we could implement a stack. It is a very natural way of implementing it, since if we put new items at the top of the stack, then popping them from the top automatically fulfills the requirement of removing the most recently added element.<br><br>

However, we could have implemented a stack differently, since a stack is an ADT, and ADTs don't tell us the implementation details.
<h2 id="L22-queue">Queue ADT</h2>
<div class="alert alert-success" role="alert"><br>
    A <b>queue</b> is a collection of elements with the operations <code>enqueue</code> and <code>dequeue</code>
    <ul>
        <li><code>enqueue</code> inserts the elements into the collection</li>
        <li><code>dequeue</code> removes the <i>earliest added element that's not yet removed and returns it</i></li>
    </ul>
</div>
The anlogy for queues is a physical queue (i.e. a line of people). If we have a queue of people waiting to get into the Praxis lecture, the first person in the queue is the first person to get in (and therefore leave the queue). This is known as FIFO (first in first out). An example starting with an empty list:
<ol>
    <li><code>enqueue(1)</code></li>
    <li><code>enqueue(50)</code></li>
    <li><code>dequeue()</code> (returns 1)</li>
</ol>
<h2 id="L22-implementation-stack">Implementation of Stack</h2>
We can use a python list to act as a stack very naturally,
<pre><code class="python">class Stack:
    def __init__(self):
        self.data = []
    
    def push(self, item):
        self.data.append(item)
    
    def pop(self):
        return self.data.pop()</code></pre>
This is because the Python <code>pop()</code> already acts like the stack <code>pop()</code> operation. It removes the last element of the list and returns it. While the above works perfectly fine, for the sake of learning, we will implement a stack without using these default methods (which allows us to extend concepts to other ADT implementations). We have,
<pre><code class="python">class Stack:
    def __init__(self):
        self.data = []
    
    def push(self, item):
        self.data.append(item)
    
    def pop(self):
        # return self.data.pop()
        ret_val = self.data[-1]
        del self.data[-1]
        return ret_val

if __name__ == '__main__':
    s = Stack()
    s.push(1)
    s.push(50)
    print(s.pop())
    s.push(100)
    print(s.pop())
    print(s.pop())</code></pre>
which will output <code>50, 100, 1</code> as we predicted earlier.
<h2 id="L22-implementation-queue">Implementation of Queue</h2>
I claim that this is trivial to do if we have the previous section. Why is this the case?
<br><br>

The reason is that the only difference between a stack and a queue is whether we choose to remove the most recent element or the earliest element. This means making a small change in the index is sufficient (i.e. <code>-1</code> to <code>0</code>)
<pre><code class="python">class Queue:
    def __init__(self):
        self.data = []
    
    def enqueue(self, item):
        self.data.append(item)
    
    def dequeue(self):
        ret_val = self.data[0]
        del self.data[0]
        return ret_val

if __name__ == '__main__':
    s = Queue()
    s.enqueue(1)
    s.enqueue(50)
    print(s.dequeue())
    s.enqueue(100)
    print(s.dequeue())
    print(s.dequeue())</code></pre>
which prints out <code>1 50 100</code> as expected.
<h2 id="L22-complexity">Complexity</h2>
This seems boring for such a simple data structure, but it is actually very exciting! First, note that the time complexity of <code>push</code> and <code>enqueue</code> is the same as the time complexity of appending to a list. This is \(\mathcal{O}(1)\) but it's not obvious why this is the case!
<ul>
    <li>If we were to implement this in C via an array, we can allocate extra memory such that writing to the array is \(\mathcal{O}(1)\). However, if we add enough elements to the array, then we run out of space and need to re-allocate memory, making the worst case scenario \(\mathcal{O}(n)\).</li>
    <li>However in practice, this worst case scenario above isn't actually that bad. If every time we run out of memory, we double the allocated space, then there's only so many times we need to reallocate space (since exponents grow very fast). Note that this is a very common strategy people use.</li>
</ul>
In Python, lists are implemented <a href="https://wiki.python.org/moin/TimeComplexity">internally</a> as an array, so the above analysis applies as well.<br><br>

Retrieving elements in an array by index and deleting the last element of an array are both \(\mathcal{O}(1)\) so the time complexity of <code>pop</code> is \(\mathcal{O}(1)\)<br><br>

However, <code>dequeue</code> is \(\mathcal{O}(n)\). This is because once the item at index 0 is removed, the item that used to be at index 1 needs to be at index 0. In order for this to happen, the rest of the elements need to be shifted to the left, so a total of 10 operations are done.
<h2 id="L22-improvement">Improving Queues</h2>
Our naive implementation of a queue is very inefficient. Intuitively, a simple task such as removing the leftmost element can be done in constant time, so how can we fix this?<br><br>

We can use linked lists!
<center>
    <img src="diagrams/linked_list_queue.png.jpg" class="img-fluid" alt="...">
</center>
Refer to the above diagram. The basic idea is that if we remove the first element, instead of shifting everything to the left, we can just change the <code>HEAD</code> pointer of the linked list to direct to the second element, which takes \(\mathcal{O}(1)\) time. We can implement this as follows:
<pre><code class="python">import linkedlist

class LLQueue:
    def __ini__(self):
        self.data = linkedlist.LinkedList()
    
    def enqueue(self):
        self.data.append(item)
        
    def dequeue(self):
        ret_value = self.data.head.value
        self.data.head = self.data.head.next</code></pre>
where <code>linkedlist</code> is the code we wrote in Lecture 21. Note that there is one problem. In order to append, we had to traverse the entire linked list, so the time complexity for <code>enqueue</code> is now \(\mathcal{O}(n)\). We can fix this by modifying the linked list implementation to keep track of the tail of the linked list, so that appending is \(\mathcal{O}(1)\). That is,
<pre><code class="python">class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None</code></pre>
Note that we now have to edit our existing functions so that it updates the tail pointer as well when we append and insert. See (and visualize) the changes that were made <a href="https://github.com/QiLinXue/esc190-notes/commit/3fe8daba4b99358152a34e187fcba656932ccba6">here!</a> The updated linked list file is
<pre><code class="python">class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
    
    def get_i(self, i):
        # return the value at index i
        cur = self.head
        for j in range(i):
            cur = cur.next
        return cur.value

    def append(self, value):
        '''Add a new node with the value value to the end of the list'''
        # Create a new node
        new_node = Node(value)
        
        if self.head == None:
            self.head = new_node
            self.tail = new_node

        self.tail.next = new_node
        self.tail = new_node
    
    def insert(self, value, i):
        '''Insert a node with the value value at index i'''
        new_node = Node(value)

        if i == 0:
            new_node.next = self.head
            self.head = new_node
        
        else:
            cur = self.head
            for j in range(i-1):
                cur = cur.next
            new_node.next = cur.next
            cur.next = new_node
        
        if new_node.next == None:
            self.tail = new_node

    def __str__(self):
        cur = self.head
        s = ""
        if(cur == None):
            return "Empty list :("
        
        while cur != None:
            print(cur)
            s += str(cur) + " -> "
            cur = cur.next
        return s[:-4] # remove last arrow
</code></pre>
Note that the lecture had a minor typo. In the lecture, <code>self.tail</code> was initially set to <code>None</code> but it was never initialized, so running something like <code>self.tail.next = new_node</code> would lead to an error. <br><br>

This is one very practical case where linked lists come in handy. The native implementation of queues in Python is via <code>collections.deque</code> which does it via doubly linked list, similar to what we constructed above.

<h1 id="L23">L23: Midterm Question (PyInteger)</h1>
In this lecture, we review the midterm: specifically question 5 where we are asked to implement the ADT <code>pyinteger</code> which allows us to represent arbitrarily large integers and perform the two basic operations,
<ul>
    <li><code>plusplus(n1)</code> adds <code>1</code> to the <code>pyinteger n1</code></li>
    <li><code>add(n1, n2)</code> adds the <code>pyinteger n2</code> to the <code>pyinteger n1</code></li>
</ul>
We first set up our header file, <code>pyinteger.h</code>:
<pre><code class="c">#if !defined(PYINTEGER_H)
#define PYINTEGER_H

typedef struct pyinteger{
    int *digits;
    int size;
    int capacity;
} pyinteger;

void plusplus(void *pyint);
void add(pyinteger *pyint1, pyinteger *pyint2);

#endif</code></pre>
where <code>pyinteger</code> is a struct that contains the following fields:
<ul>
    <li><code>digits</code> is a pointer to an array of integers that stores the digits of the integer</li>
    <li><code>size</code> is the number of digits in the integer</li>
    <li><code>capacity</code> is the maximum number of digits that can be stored in the array</li>
</ul>
Here, we are representing an integer via an array where each element in this array is a digit from 0-9. For example, the integer 1234 would be represented as <code>[1, 2, 3, 4]</code>. We use a similar approach to the one we used in Lecture 21 to update the <code>capacity.</code> Every time the capacity is reached and we need to add another digit, we double the capacity of the array.
<h2 id="L22-creating">Creating the Struct</h2>
Now we work in <code>pyinteger.c</code> and we wish to implement the ADT. But first, we can create an optional function that allows us to create a <code>pyinteger</code> struct which initially stores <code>int n</code>. What are some natural tasks that we must do?
<ul>
    <li>How can we determine the initial <code>capacity</code>? In other words, how do we make sure we initially allocated enough space for our array?</li>
    <li>How can we put the digits into the array <code>*digits</code>? To do this, we need to find a good way of extracting the digits from the initial integer.</li>
</ul>
To determine the initial capacity, we need to determine the number of digits <code>int n</code> has.
<div class="alert alert-primary" role="alert">
I claim that the formula for the number of digits of \(n\) is given by 
\[\text{num of digits} = \text{floor}(\log_{10}(n)) + 1.\]</div>
<div class="alert alert-dark" role="alert">
<i>Proof:</i> A \(k\)-digit number can be written as 
\[n = a_{k-1}10^{k-1} + a_{k-2}10^{k-2} + \cdots + a_110^1 + a_.\]
where the leading coefficient \(a_{k-1} \neq 0\). To double-check this, note that \(15 = 1 \times 10^1 + 5\) so the leading power is \(k-1\). Note that:
\[10^{k-1} \le n < 10^k.\]
It is important that the right inequality is strict! Since the logarithm is a monotonically increasing function, we have
\[\log_{10}(10^{k-1}) \le \log_{10}(n) < \log_{10}(10^k)\]
or equivalently, 
\[k-1 \le \log_{10}(n) < k.\]
Therefore, \(\text{floor}(\log_{10}(n))=k-1\) so
\[k = \text{floor}(\log_{10}(n)) + 1\]
as expected.<br><br>

<b>However:</b> If \(n=0\) then we get something that is undefined, so we have to treat this case separately.</div>
Obviously, you are not expected to prove this on the midterm, but I provided the proof here for those who are interested and for the rigour. It's a handy fact to know though, so you don't need to be stressed about weird edge cases!

The process of extracting the digits from the integer is a bit tricky, but it's something that we've done before! To get the last digit, we can compute
\[n \% 10.\]
To get the second to last digit, we can shift all the digits by diving the number by \(10\) and ignoring the decimal part. Then we can repeatedly apply this same algorithm until we have no more digits left. Therefore, we should start from the end of the array and work our way backwards. Here is the code:
<pre><code class="C">void create_integer(pyinteger **pyint, int n){
    // Allocate memory for the pyinteger struct
    *pyint = (pyinteger*)malloc(sizeof(pyinteger));

    // Proven in a theorem
    if (n == 0){
        (*pyint)->capacity = 1;
    }
    else{
        (*pyint)->capacity = (int)(log10(n)) + 1;
    }

    // Currently the number of digits is the same as the capacity
    (*pyint)->num_digits = (*pyint)->capacity;

    // Allocate memory for the digits
    (*pyint)->digits = (int*)malloc(sizeof(int) * (*pyint)->capacity);

    // Fill the digits
    for (int loc = (*pyint)->num_digits - 1; loc >= 0; loc--){
        (*pyint)->digits[loc] = n % 10;
        n /= 10;
    }
}</code></pre>
<h2 id="L22-plus-plus">Implementing PlusPlus</h2>
Now we need to implement the function <code>plusplus</code>. This function should add <code>1</code> to the integer. Why might this be a tricky task? Well, the naive approach is to just add <code>1</code> to the units digit, but if the units digit is \(9\), then something weird might happen. Let's break it up into two cases, and work with the easier case first (this is a good idea in a test situation, since you know there will definitely be partial marks)
<ul>
    <li>Case 1: The units digit is not 9. We simply get the value at index <code>pyint->num_digits - 1</code> and check if it's a 9. If not, then we increment it by 1!</li>
    <li>Case 2: We draw analogy from long addition. We change the 9 into a 0, then carry over to the previous digit. If that digit is not 9, we add 1. If it is 9, we change it into a 0 and continue.</li>
</ul>
we can implement it (with a small hiccup we'll discuss in a bit) as follows:
<pre><code class="c">void plusplus(pyinteger *pyint){
    int loc;
    for (loc = pyint->num_digits - 1; loc >= 0; loc--){
        if (pyint->digits[loc] == 9){
            pyint->digits[loc] = 0;
        } else {
            pyint->digits[loc]++;
            break;
        }
    }
}</code></pre>
Note that at this stage, there is one more hiccup. If everything is 9, then the size of the number can increase! This specific case is a bit annoying, but just doing everything up to this point will give you 8/10 points. <i>If you can't fully figure how to solve a question, solving it partially can still land you a lot of points!</i>
<br><br>

So how do we fix this? To deal with this case, we ask the following natural questions:
<ul>
    <li>How can we even detect if we need to do this case?</li>
    <li>How do we decide if we need to re-allocate memory?</li>
    <li>How do I shift the digits? (This is actually a bit misleading, as we'll see in a bit)</li>
</ul>
To detect if we even need to consider this case, there are many ways to do so. One way is to check the value of <code>loc</code> after the for loop finishes. If the for loop exits via the break statement, we should have <code>loc >= 0.</code> If it doesn't exit via the break statement, that means the first digit was also a 9, so <code>loc == 0.</code><br><br>

How can we check if we need to re-allocate memory? At this point, we know that the number of digits has increased by 1, so we can update <code>num_digits.</code> Now we can check if the number of digits is greater than the capacity. If it is, then we need to re-allocate memory. We can do this by doubling the capacity.<br><br>

Finally, we need to be able to shift all the digits over. At least, this was my first thought when I saw the problem. However, if we work through a simple example (or think about it), at this point, every single digit should be 0! Therefore, all we need to do here is set the first digit to 1. Easy!
<pre><code class="c">void plusplus(pyinteger *pyint){
    int loc;
    for (loc = pyint->num_digits - 1; loc >= 0; loc--){
        if (pyint->digits[loc] == 9){
            pyint->digits[loc] = 0;
        } else {
            pyint->digits[loc]++;
            break;
        }
    }

    if(loc == -1){
        pyint->num_digits++;
        if(pyint->num_digits > pyint->capacity){
            pyint->capacity *= 2;
            // Reallocate memory for the digits
            pyint->digits = (int*)realloc(pyint->digits, sizeof(int) * pyint->capacity);
        }
        
        // First digit is 1
        pyint->digits[0] = 1;
    }
}</code></pre>
<h2 id="L22-add">Implementing Add</h2>
Now we need to implement adding. First, why might this be a hard task? It's because the digits are not aligned in a "nice" manner. When we learn long addition in elementary school, we align the rightmost digit (ones digit) of the two numbers. But the way we implemented it here, we align the leftmost digit.<br><br>

Note: we did not get to finish this in class, but here are some ideas for solutions
<ul>
    <li>Partial Solution: You can call <code>plusplus()</code> multiple times. This is very easy to implement, since all you have to figure out is how to implement a for loop that adds 1 to <code>n1</code> a total of <code>n2</code> times.<br><br>
    
    One way to do this is to create a helper function to compare two pyintegers. Then we can create a temporary <code>pyinteger</code> and initialize it to 0. We then increment both this temporary pyinteger and <code>n1</code> until the temporary pyinteger is equal to <code>n2</code>.<br><br>

    This is not optimal, since the time complexity is \(\mathcal{O}(n\log n)\) while the optimal complexity is \(\mathcal{O}(\log n)\). Because we care about time complexity in this course, you will not receive full marks, but it's possible to receive 8/10 points.
</li>
<li>
    Another way to solve this is to get rid of the annoying problem. Modify the <code>pyintegers</code> such that the units digit align. This can be done by shifting the digits over and filling everything before the leading digit with 0s. Then we can apply the standard long addition algorithm we learned in elementary school. Just remember to shift the digits back after we're done!
</li>
<li>
    Another way uses the same idea as above, but instead of shifting the digits, we can reformulate the standard "long addition" algorithm with indices, to make it easier to implement with code. Then all we have to do is write the algorithm with the C language!
</li>
</ul>
Note: This section will get updated depending on the direction of Friday's class.
        <br><br>
<br><br><br><br><br>
</div>
    </div>
  </body>
</html>