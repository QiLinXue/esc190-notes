<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YCY17GV3DB');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen" charset="utf-8">

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
    crossorigin="anonymous"
  ></script>
  <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>
      
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-19048260-11", "auto");
  ga("send", "pageview");

  hljs.highlightAll();
</script>
</head>
<body data-bs-spy="scroll" data-target="#toc">
  <div class="container">
    <div class="row">
      <div class="col-sm-3">
        <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
      </div>
      <div class="col-sm-9">


<h1 id="-esc190-lecture-notes">ESC190 Lecture Notes: Part 2<br> Data Structures and Basic Algorithms</h1>
    <p>See all lecture notes <a href="../">here</a>.</p>
    </p>

<h1 id = "L11">L11: Sorting</h1>
<h2 id="L11-qsort">qsort</h2>
C has a built-in function called qsort that can be used to sort an array of elements. The function takes in 4 arguments:
<ol>
    <li>The array to be sorted</li>
    <li>The number of elements in the array</li>
    <li>The size of each element in the array</li>
    <li>A function that compares two elements in the array. It should return</li>
    <ul>
        <li>A negative number if the first element is smaller than the second element</li>
        <li>0 if the two elements are equal</li>
        <li>A positive number if the first element is larger than the second element</li>
    </ul>
</ol>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
    
int compare_ints(const void *p_a, const void *p_b)
{
  int *p_a_i = (int *)p_a;
  int *p_b_i = (int *)p_b;
  return *p_a_i - *p_b_i;
}
    
int main()
{
  int arr[] = {6, 5, 10, 2};
  qsort(arr, 4, sizeof(int), compare_ints);
}
</code></pre>
The reason the compare function takes in void pointers is because qsort is a generic function that can be used to sort any type of data. The function then casts the void pointers to the correct type and compares the two elements. This allows us to be more creative. Suppose we have our own structure to represent students, and we wish to sort them by their age. If two students have the same age then we wish to sort them by their name. We can do this by writing a compare function that compares the ages first and then compares the names if the ages are equal. We have,
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct student1{
  char name[20];
  int age;
} student1;

int compare_student1s(const void *p_a, const void *p_b)
{
  // Want to sort student1's by name
  // If students have the same age, sort by name

  student1 *p_a_s = (student1 *)p_a;
  student1 *p_b_s = (student1 *)p_b;
  int age_diff = p_a_s->age - p_b_s->age;
  if(age_diff != 0)
  {
    return age_diff;
  }else{
    return strcmp(p_a_s->name, p_b_s->name);
  }
}

int main()
{
  student1 s1_arr[] = {{"John", 20}, {"Jill", 21}, {"Jack", 21}};

  qsort(s1_arr, 3, sizeof(student1), compare_student1s);

  for (int i = 0; i < 3; i++)
    printf("%s %d\n", s1_arr[i].name, s1_arr[i].age);
}
</code></pre>
Note that:
<ul>
    <li>We can use curly braces to initialize a struct</li>
    <li>The <code>strcmp</code> function compares two strings and returns a negative number if the first string is smaller than the second string, 0 if the two strings are equal, and a positive number if the first string is larger than the second string</li>
</ul>

<h2 id="L11-reading-files">Reading Files</h2>
Quick tip: When copying a file, download it instead of copying and pasting. When copying, you may accidentally ruin the formatting of the file.<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
  FILE *fp = fopen("cities.txt", "r");
  char line[200];
  fgets(line, 200, fp);
  line[strlen(line) - 1] = '\0';
  int num_items = atoi(line);

  return 0;
}
</code></pre>
The code works via the following:
<ol>
    <li>Within <code>main</code>, a file pointer <code>fp</code> is created and is assigned the result of opening the file <code>cities.txt</code> in read mode. If the file doesn't exist, <code>fopen</code> returns <code>NULL</code>.</li>
    <li>A character array <code>line</code> with a maximum size of 200 characters is declared.</li>
    <li>The function <code>fgets</code> is called, which reads a line of text from the file pointed to by <code>fp</code> and stores it in the <code>line</code> array. The maximum number of characters to be read is specified as 200, the second argument to <code>fgets</code>.</li>
    <li>The last character of <code>line</code>, which is the newline character, is replaced with a null terminator (<code>'\0'</code>) to end the string.</li>
    <li>The function <code>atoi</code> is called with <code>line</code> as its argument, which converts the string representation of a number to its integer value. This is <code>93827</code> for the project, the total number of cities.</li>
  </ol>
Alternatively, we can use <code>fgets</code> to read the entire file line by line. This is useful if we want to read the file line by line and do something with each line.

<h1 id="L12-bubble-sort-again">L12: Bubble Sort</h1>
Bubble sort was gone over very quickly last lecture, so this lecture will go over it in more detail.
<h2 id="L12-bubble-sort">Bubble Sort</h2>
Bubble sort is a simple sorting technique that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm gets its name from the way smaller elements "bubble" to the top of the list. The pseudocode is given by (from Wikipedia),<br><br>
<pre>
function bubbleSort(L)
    n = length(L)
    repeat
        swapped = false
        for i=1 to n-1 inclusive do
            /* if this pair is out of order */
            if A[i-1] > A[i] then
                /* swap them and remember something changed */
                swap(A[i-1], A[i])
                swapped = true
            end if
        end for
    until not swapped
end function
</pre>
<div class="card">
  <h3 class="card-header">Exercise</h5>
  <div class="card-body">
    Consider the below sequence. Manually apply bubble sort:
    <pre>
5, 2, 10, 56, 15
    </pre>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    Each line represents a different step:
<pre>
5, 2, 10, 56, 8
2, 5, 10, 56, 8 // 2 and 5 swapped
2, 5, 10, 56, 8 // 5 and 10 in order
2, 5, 10, 56, 8 // 10 and 56 in order
2, 5, 10, 8, 56 // 56 and 8 swapped
// Go back to beginning
2, 5, 10, 8, 56 // 2 and 8 in order
2, 5, 10, 8, 56 // 5 and 10 in order
2, 5, 8, 10, 56 // 8 and 10 swapped
2, 5, 8, 10, 56 // 10 and 56 in order
// Go back to beginning
2, 5, 8, 10, 56 // 2 and 5 in order
2, 5, 8, 10, 56 // 5 and 8 in order
2, 5, 8, 10, 56 // 8 and 10 in order
2, 5, 8, 10, 56 // 10 and 56 in order
</pre>
</div></div></div></div>
In C, it can be implemented as,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void bubble_sort(void *arr, int num_items, int item_size,
                 int (*compare)(const void *, const void *))
{
  int i, j;
  void *temp = malloc(item_size);

  for (i = 0; i < num_items - 1; i++){
    for (j = 0; j < num_items - i - 1; j++){
      // compare arr[j] and arr[j + 1], swap if necessary
      // arr[j] only makes sense if array is of type int*, float*, etc.
      void *p_j = arr + j * item_size;
      void *p_j1 = arr + (j + 1) * item_size;

      // Now can compute compare(p_j, p_j1)
      if (compare(p_j, p_j1) > 0){
        // kind of want to swap *p_j and *p_j1
        memcpy(temp, p_j, item_size); // temp = *p_j
        memcpy(p_j, p_j1, item_size);
        memcpy(p_j1, temp, item_size);
      }
    }
  }
  free(temp);
}

int compare_int(const void *p_a, const void *p_b)
{
  const int *x = (const int *)p_a;
  const int *y = (const int *)p_b;
  return *x - *y;
}

int main()
{
  int arr[] = {64, 34, 25, 12, 22, 11, 90};
  int num_items = sizeof(arr) / sizeof(arr[0]);
  bubble_sort(arr, num_items, sizeof(int), compare_int);

  for (int i = 0; i < num_items; i++)
    printf("%d ", arr[i]);

  return 0;
}
</code></pre>
Here are some comments about the signature of the <code>bubble_sort</code> function:
<ul>
    <li><code>void *arr</code>: This is a pointer to the array to be sorted. The data type of the array is not specified, so the function can be used with arrays of any data type.
    </li>
    <li><code>int (*compare)(const void *, const void *)</code> is a pointer to a comparison function. The comparison function takes two pointers to void as arguments and returns an integer less than, equal to, or greater than zero, depending on the result of the comparison. This allows the function to be used with arrays of any data type and to sort the array in any order.</li>
</ul>
Note that when we swap two elements in the array, we need to use the <code>memcpy</code> function to copy the data from one element to another. This is because we don't know the data type of the elements in the array.<br><br>The <code>memcpy</code> function takes three arguments: the destination, the source, and the number of bytes to copy. The destination and source are both pointers to void, so we can use the <code>swap</code> function with arrays of any data type.
<div class="card">
  <h3 class="card-header">Exercise</h5>
  <div class="card-body">
    Consider the above code. It is actually inefficient and not the most ideal implementation of bubble sort. Why? (Hint: Compare this to the pseudocode)
<br><br>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    There is no stop condition. If the array is somehow fully sorted halfway into the program, it will still run to the very end (even if you pass in an already sorted array!)
  </div>
</div>
</div>
</div>
<h2 id="detailed-bubble-sort">Optimizing Bubble Sort</h2>
We can modify the program such that if a full pass through the array is made without any swaps, then the array is already sorted and we can stop the program. This can be done by modifying the <code>bubble_sort</code> function as follows:
<pre><code class="language-C">void bubble_sort(void *arr, int num_items, int item_size,
                 int (*compare)(const void *, const void *))
{
  int i, j;
  void *temp = malloc(item_size);

  for (i = 0; i < num_items - 1; i++)
  {
    int swapped = 0;
    for (j = 0; j < num_items - i - 1; j++)
    {
      // compare arr[j] and arr[j + 1], swap if necessary
      // arr[j] only makes sense if array is of type int*, float*, etc.
      void *p_j = arr + j * item_size;
      void *p_j1 = arr + (j + 1) * item_size;

      // Now can compute compare(p_j, p_j1)
      if (compare(p_j, p_j1) > 0)
      {
        // kind of want to swap *p_j and *p_j1
        memcpy(temp, p_j, item_size); // temp = *p_j
        memcpy(p_j, p_j1, item_size);
        memcpy(p_j1, temp, item_size);
        swapped = 1;
      }
    }
    if (!swapped){
      break; // return could cause a memory leak
             // could go free(temp) and return
    }
  }
  free(temp);
}
</code></pre>

<h1 id="L13">L13: Patch</h1>
Refer to the pre-lecture code <a href="https://www.cs.toronto.edu/~guerzhoy/190/lec/W05/patch.c">patch.c</a> and <a href="https://www.cs.toronto.edu/~guerzhoy/190/lec/W05/patch.py">patch.py</a>
<h2 id="L13-GDB">Using GDB</h2>
First, compile <code>patch.c</code> and you should get an output file. See Lecture 10 for more information on compiling C code. After it is compiled, we can run 
<pre><code class="language-bash">gdb patch</code></pre>
Then typing 
<pre><code class="language-bash">layout asm</code></pre>
we are able to get the machine instructions that comprise the code. You don't need to worry about this right now, you'll learn about it in 2nd year ECE253 :) The only thing we need to understand is that the compiler is able to translate the C code into machine code, which gives very simple instructions.
<h2 id="L13-changing-g">Changing a Function</h2>
The goal of this exercise is to change the function <code>g</code> such that it behaves like the function <code>f</code>. They are defined as follows:
<pre><code class="language-C">int f(int a, int b, int c)
{
    return a + b;
}

int g(int a, int b, int c)
{
    return a + c;
}
</code></pre>
When looking at the machine instructions, I obtain the following snippet:
<pre><code class="language-assembly">
│   0x1189 &lt;f&gt;              endbr64
│   0x118d &lt;f+4&gt;            push   %rbp
│   0x118e &lt;f+5&gt;            mov    %rsp,%rbp
│   0x1191 &lt;f+8&gt;            mov    %edi,-0x4(%rbp)
│   0x1194 &lt;f+11&gt;           mov    %esi,-0x8(%rbp)
│   0x1197 &lt;f+14&gt;           mov    %edx,-0xc(%rbp)
│   0x119a &lt;f+17&gt;           mov    -0x4(%rbp),%edx
│   0x119d &lt;f+20&gt;           mov    -0x8(%rbp),%eax
│   0x11a0 &lt;f+23&gt;           add    %edx,%eax
│   0x11a2 &lt;f+25&gt;           pop    %rbp
│   0x11a3 &lt;f+26&gt;           retq
│   0x11a4 &lt;g&gt;              endbr64
│   0x11a8 &lt;g+4&gt;            push   %rbp
│   0x11a9 &lt;g+5&gt;            mov    %rsp,%rbp
│   0x11ac &lt;g+8&gt;            mov    %edi,-0x4(%rbp)
│   0x11af &lt;g+11&gt;           mov    %esi,-0x8(%rbp)
│   0x11b2 &lt;g+14&gt;           mov    %edx,-0xc(%rbp)
│   0x11b5 &lt;g+17&gt;           mov    -0x4(%rbp),%edx
│   0x11b8 &lt;g+20&gt;           mov    -0xc(%rbp),%eax
│   0x11bb &lt;g+23&gt;           add    %edx,%eax
│   0x11bd &lt;g+25&gt;           pop    %rbp
│   0x11be &lt;g+26&gt;           retq 
</code></pre>
Some brief comments about this structure:
<ul>
  <li>Each line is an instruction. Each byte of instruction is stored in a different location in memory. The first set of characters represent the memory in hexadecimal.</li>
  <li>The <code>mov</code> command moves data from one location to another. The first argument is the destination, the second argument is the source.</li>
  <li>In GDB, we can display the value at an address with the command <code>x 0x119d</code>, which in this particular example gives <code>0x119d &lt;f+20&gt;:  0x01f8458b</code>. The hexadecimal number 0x01f8458b encodes the instructions for that line. We can display it as a decimal if we do <code>x/d 0x119d</code> which outputs <code>0x119d &lt;f+20&gt;:  33047947</code></li>
</ul>
If we compare the machine code for both functions, they differ by only one line! Compare &lt;f+20&gt; with &lt;g+20&gt;. If we wish to modify <code>g</code> such that it acts like <code>f</code>, we just need to change what this one line does in memory. This is done using the following code. Consider,
<pre><code class="language-C">void patch(int (*h)(int, int, int))
{
    *(int *)((void*)h + 20 )  = 33047947; //0x01f8458b;
}
</code></pre>
Here is what this function does:
<ol>
  <li>It takes in the pointer to a function. Recall that if we want to modify <code>int a = 5;</code> inside a function, we need to pass in the address. The same goes here if we want to modify a function.</li>
  <li>We cast the pointer to a void pointer (i.e. not associated with any data type) using <code>(void*)h</code>.</li>
  <li>Note that <code>(void*)h</code> is the address of the start of the function. To get to the part of the function or instructions we actually want to change, we need to increment the address by 20 bytes (which we said earlier was the only place that it differed from <code>f</code>).</li>
  <li><code>(void*)h + 20</code> is a void pointer that points to the line of instruction we want to change. But we've seen that instructions are encoded by a number, so we need to cast this to an int pointer via <code>(int *)((void*)h + 20)</code>.</li>
  <li>We've seen that the instruction we want to change this to can be represented as an integer as <code>33047947</code>, so we write this into memory at this address.
    <ul>
      <li>Clarification: Note that an integer is 4 bytes but the instruction at <code>0x11b8 &lt;g+20&gt;</code> is 3 bytes, since the next instruction is at <code>0x11b8 &lt;g+20&gt;</code>. The reason this still works is because the instruction at <code>0x11bb &lt;g+23&gt;</code> and <code>0x11a0 &lt;f+23&gt;</code> is the same, so the 4th byte will be overwritten with a byte that is equal to it.
      </li>

    </ul>
  </li>
</ol>
Note that this particular example is not very useful, as it's not a good practice and very difficult to debug, hopefully for obvious reasons. Sometimes it's done for optimizations, but we don't need to worry about that. 
<h2 id="L13-python-weirdness">Python Memory Model Weirdness</h2>
Consider the following code,
<pre><code>import ctypes

def change_float(x):
    # Go to the memory address of x and change the value there
    pointer = ctypes.c_void_p(id(x))
    float_pointer = ctypes.cast(pointer, ctypes.POINTER(ctypes.c_double))
    float_pointer[2] = 12.0



if __name__ == '__main__':
    x = 11.0
    change_float(x)
    print(x) # 12.0
    print(x == 11.0) # True
    print(11.0 == 12.0) # True
    print(10+1.0 < 10+2.0) # False
</code></pre>
Surprisingly, this prints<pre><code class="language-bash">12.0
True
True
</code></pre>
As a quick reminder, in Python, variables are essentially just names that are bound to objects. When you pass a variable to a function in Python, what is actually passed is a reference to the object, rather than a copy of the object itself. The code works via,
<ol>
  <li>Inside the function, the <code>id</code> function is used to get the memory address of the object, and uses the <code>ctypes</code> module to cast that memory address to a pointer to a <code>ctypes.c_double</code> type. There is some nomenclature confusions here,
  <ul>
    <li>In C, a <code>double</code> is a double-precision floating point number (usually 64 bits) while a <code>float</code> is a single-precision floating point number (usually 32 bits)</li>
    <li>In Python, a float is the same as a double in C.</li>
  </ul>
  </li>
  <li>
    The line <code>float_pointer[2] = 12.0</code> is setting the value stored at the memory location pointed to by float_pointer to be <code>12.0</code>.
  </li>
  <li>
    This line of code modifies the memory of the float object that was passed to the change_float function, so that the address at which the values <code>x</code> and <code>12.0</code> are stored, is the same, so <code>x == 12.0</code> and their values are equal. However, the object <code>x</code> and <code>11.0</code> are identical (i.e. they have the same id so Python doesn't both checking their actual values), so we also have <code>x == 11.0</code> and <code>11.0 == 12.0</code> (since 11.0 is the same object as <code>x</code>).<br><br>

    Note that the memory representation of an object is the way that the value of the object is stored in computer memory, while the id is a unique identifer that is assigned to each object. Two objects could have different ids but the same memory representation. The reason this is allowed is because the <code>ctypes</code> module is allowing the user to bypass Python's memory management and directly access memory, which is not typically recommended or necessary.
  </li>
  <li>The reason the last three lines work is that the 11.0 literal is mapped to refer to a single id address since it appears in the code several times. So <code>print(10+1.0 < 10+2.0)</code> will still print False.</li>
</ol>
It's important to recognize that this is not recommended for general use, as it relies on implementation-specific details and can lead to unexpected behavior and make the code difficult to understand and maintain. It's best to stick to the standard Python operations and data structures, which provide a more predictable and stable behavior.<br><br>





What do I need to know and don't know?
<ul>
  <li>Know: Python and C memory model</li>
  <li>Don't Know: Machine Code and how to use <code>ctypes</code> in Python</li>
</ul>
<br><br><br><br><br>
 
  </body>
</html>