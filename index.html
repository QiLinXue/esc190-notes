<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YCY17GV3DB');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen" charset="utf-8">

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
    crossorigin="anonymous"
  ></script>
  <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>
      
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-19048260-11", "auto");
  ga("send", "pageview");

  hljs.highlightAll();
</script>
</head>
<body data-bs-spy="scroll" data-target="#toc">
  <div class="container">
    <div class="row">
      <div class="col-sm-3">
        <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
      </div>
      <div class="col-sm-9">


<h1 id="-esc190-lecture-notes">ESC190 Lecture Notes</h1>
    <p>These are official course notes for ESC190: Computer Algorithms and Data Structures.
      <br><br>
      I will do my best to update notes within 24 hours of the lecture recording being posted. If you have any feedback, questions, clarifications, or if you see a typo or a mistake, feel free to email me at <a href="mailto:qilin.xue@mail.utoronto.ca">qilin.xue@mail.utoronto.ca</a>.
      <br><br>
      Cheers!<br>
      QiLin
    </p>
<h1 id="L2">L2: Introduction to C, pointers and dereferencing</h1>
<h2 id="L2-syntax">Variables</h2>
Like Python, there are different types of variables. Unlike Python, you need to declare what type it is when you initialize. After initializing, we can only change this variable to another value of the same type.
<pre><code class="language-C">#include &lt;stdio.h&gt
int main(){
    int a = 42; // Need to initialize the type of variable
    a = 43; // Changing the value of an already initialized variable
    // a = "hi"; will give an error or warning!

    printf("%d\n", a); // Prints 43

    return 0;
}
</code></pre>
Why does C do this? Because compiler needs to assign the appropriate space in the memory table. Therefore, we need to think of variables in a slightly different way. When the code initializes, it stores 42 in memory, i.e. at address 3040 (nothing inherently special about this number, only here so we have a concrete example). <b>The program associates <code>a</code> with this address.</b> The table becomes,<br><br>
<table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>42</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  After the line <code>a = 43;</code> is run, the program will look at the address in which the value of <code>a</code> is stored, and change that value to 43. The table then changes to,<br><br>
  <table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>43</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td></td>
      </tr>
    </tbody>
  </table>
 Note that this is not how Python works. Changing the value of a variable will change the address of that variable. C is therefore <i>more</i> intuitive in the sense that variables are associated with a location in physical memory.
 
 Finally, the line <code>printf("%d\n",a)</code> tells us to print the value of <code>a</code>. The format specifier <code>%d</code> tells the program to interpret <code>a</code> as an integer, and <code>\n</code> tells the code to make a line break. Here is a list of <a href="https://www.tutorialspoint.com/format-specifiers-in-c">format specifiers.</a>
 <h2 id="L2-pointers">Pointers</h2>
 We can store the address of variables using <i>pointers.</i> To create a variable <code>p_a</code> that can store the address of another variable, we use the <code>int*</code> type. The operator <code>&</code> retrieves the address of a given variable.
<pre><code class="language-C">#include &lt;stdio.h&gt
int main(){
    int a = 42;
    int* p_a = &a; // & is the "address-of" operator
                   // int* is the type "address of int"
    printf("%ld\n", p_a); // %ld specifies a long integer
    return 0;
}</code></pre>
In the above code, <code>p_a</code> stores the address of <code>a</code>, which if we continue to use our earlier memory table, is equal to 3040. We can print the pointer using the type specifier <code>%ld</code>, as pointers are stored as long integers (which takes twice as more bits than regular integers).<br><br>

Typically, long integers are 64 bits on most systems and integers are 32 bits. If you haven't noticed, this is why the addresses in our example tables go up by 32! (to make visualization easier)<br><br>

The above code may give a warning (depends on system) that the formats that <code>%ld</code> expects and the variable given don't match, as <code>p_a</code> technically has type <code>int*</code>. However, because we can represent <code>p_a</code> as a long integer, we can cast it by running <code class="language-C">printf("%ld\n", (long int)p_a);</code> instead.

<h2>Dereferencing Operator</h2>
The dereferencing operator is given by <code>*</code> and acts on a memory address to get the value stored in memory at that address. For example, the code <code class="language-C">int value_of_a = *p_a;</code> tells us the program to get the value of <code>p_a</code> which is an address, then go to that address, and retrieve the value stored there. Suppose we run the code
<pre><code class="language-C">#include &lt;stdio.h&gt
    int main(){
        int a = 42;
        int* p_a = &a;
        int b = *p_a; 
        return 0;
    }</code></pre> we get the following memory table:<br><br>
  <table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>43</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td><code>3040</code> (<code>p_a</code> of type <code>int*</code>)</td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td><code>43</code> (<code>b</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td></td>
      </tr>
    </tbody>
  </table> The symbol <code>*</code> is used both to define variables (i.e. as a type) and also as an operator for dereferencing. While both are used in the context of memory, they are separate.
<h2 id="L2-functions">Functions</h2>
Functions generally work mostly the same way as Python. It is important to note that when an input is passed to the function, the function makes a copy of it in the sense that it uses a different locals frame. For example,
<pre><code class="language-C">#include &lt;stdio.h&gt
    int f(int x){
        return x + 1;
    }
    int main(){
        int a = 42;
        int* p_a = &a;
        int b = *p_a; 

        int c = f(b);
        return 0;
    }</code></pre>
    which gives the additional memory table,<br><br>
    <table class="table">
        <thead>
          <tr>
            <th scope="col">Address</th>
            <th scope="col">Value</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">1280</th>
            <td><code>5</code> (<code>x</code> of type <code>int</code>)</td>
          </tr>
          <tr>
            <th scope="row">3072</th>
            <td></td>
          </tr>
          <tr>
            <th scope="row">1336</th>
            <td></td>
          </tr>
          <tr>
            <th scope="row">1368</th>
            <td></td>
          </tr>
        </tbody>
      </table>
      Therefore, if we were to change the value of <code>x</code> inside the function, it would only affect the value at address 1280, and the value of <code>b</code> (from the main memory table) will not be affected. 

<h1 id="L3">L3: Binary representation of ints, floats, and strings</h1>
At a fundamental level, computer memory can be seen as a physical table where in each cell, the voltage is either high (1) or low (0). It does not know anything about types. A single <code>0</code> or <code>1</code> is a bit, and 
<ul>
    <li>8 bits = byte</li>
    <li>kilobyte = 1024 bytes</li>
    <li>megabyte = 1000 kilobytes</li>
</ul>
The memory table stores a lot of information, including metadata. You will learn more about this in courses such as ECE253 and higher level 300+ courses. In this course, we will only deal with memory tables in the context of storing variables.
<h2 id="L4-binary">Binary</h2>
We can interpret the binary number \(1101\) as 
\[1101_\text{binary} = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 13.\]
Remark: that this is also exactly how decimals work! Also,
\[521 = 5\cdot 10^2 + 2 \cdot 10^1 + 1 \cdot 10^0.\]
It is less obvious how to go from decimal to binary. Suppose we want to convert \(25\) to binary.
<ul>
    <li>Right-to-left:</li>
    <ol>
        <li>25 is odd, so last digit in binary is \(1\). We now have to represent (25-1)/2 = 12.</li>
        <li>12 is even, so 2nd last digit in binary is \(0\). We now have to represent (12-0)/12 = 6.</li>
        <li>6 is even, so 3rd last digit in binary is \(0\). We now have to represent (6-0)/12 = 3.</li>
        <li>3 is odd, so 4th last digit in binary is \(1\). We now have to represent (3-1)/2 = 1.</li>
        <li>We can represent 1 by \(1\).</li>
    </ol>
    which gives 
    \[11001\]
    A Python implementation is given below
    <iframe src="https://trinket.io/embed/python3/7b7fd3c0aa" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
    <li>Left-to-right:</li>
    <ul>

    <li>
        The idea is that we want to write 25 as 
        \[25 = b_k2^k +b_{k-1}2^{k-1} + \cdots + b_12^1 + b_0\]
        Are we able to figure out what \(k\) is? We can determine the <i>largest power of 2 that fits into 25,</i> which is \(2^4=16\). We still need to represent \(25-16=9\)
    </li>
    <li>
        The largest power of 2 that can fit in 9 is \(2^3=8\). We then need to represent \(9-8=1\)
    </li>
    <li>
        The largest power of 2 that can fit in 1 is \(2^0=1\). We are now done.
    </li>
    We have decomposed \(25\) into powers of 2. That is,
    \[25 = 2^4 + 2^3 + 2^0 = 11001_\text{binary}.\]
    </ul>
</ul>
For 8-bit binary numbers, the 0th digit is the sign and the other 7 bits are the quantity. For example,
\[
b_0b_1b_2b_3b_4b_5b_6b_7 = \begin{cases}
+(b_12^6 + b_22^5 + b_32^4+b_42^3 + b_52^2 + b_62^1 + b_7) & \text{if }b_0 = 0 \\
-(b_12^6 + b_22^5 + b_32^4+b_42^3 + b_52^2 + b_62^1 + b_7) & \text{if }b_0 = 1
\end{cases}
\]
This is not the only way to represent numbers. Different schemes exist for different types, though there are some standard conventions (i.e. IEEE 754 for floats).

In Unicode, the first bit tells us whether we use ASCII characters (which we will use) or Unicode (which is more complicated).
<h2 id="L3-characters">Characters and Strings</h2>
The above discussion helps us understand how characters and strings are stored and worked with in C.  Consider the following program,
<pre><code class="language-C">#include &lt;stdio.h&gt
int main(){
    char c = 'x';
    printf("%c %d", c, (int)c);

    return 0;
}</code></pre>
Notice that the program outputs <code>x 120</code>. This is because we can interpret <code>c</code> as a character, so it outputs <code>'x'</code>. Alternatively, we can interpret it as an integer, in which case it outputs its ASCII value <code>120</code>.

We can store strings by writing
<pre><code class="language-C">#include &lt;stdio.h&gt
int main(){
    char* s = "Hello, World!";
    return 0;
}</code></pre>
where <code>s</code> is the address of the first character in the string (in this case, the address of 'H'). The last character in the string is <code>\0</code> (can otherwise write it as <code>0</code> or <code>NULL</code>). Therefore, the program is able to read off a string by going to the address of the first character, and moving down the table (which is where the other characters are stored) until the null character is found. Explicitly, this is stored in the memory table as (only showing part of the table)
<table class="table">
    <tbody>
      <tr>
        <th scope="row">16</th>
        <td><code>'H'</code></td>
      </tr>
      <tr>
        <th scope="row">17</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">18</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">19</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">20</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">21</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">22</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">23</th>
        <td>.</td>
      </tr>
    </tbody><tbody>
      <tr>
        <th scope="row"></th>
        <td></td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row">24</th>
        <td><code>'e'</code></td>
      </tr>
      <tr>
        <th scope="row">25</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">26</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">27</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">28</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">29</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">30</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">31</th>
        <td>.</td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row"></th>
        <td></td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row">32</th>
        <td><code>'l'</code></td>
      </tr>
      <tr>
        <th scope="row">33</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">34</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">35</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">36</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">37</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">38</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">39</th>
        <td>.</td>
      </tr>
    </tbody>
  </table>
  Here, the dot is used to denote that it takes 8 bits (1 byte) to store each character.

<h1 id="L4">L4: Strings and Changing Variables in Functions</h1>
<div class="card">
  <h2 class="card-header" id="L3-review">Warm Up Question</h5>
  <div class="card-body">
    Draw the corresponding memory table given the following program. Assume an integer takes up 4 bytes.

<pre><code class="language-C">#include &lt;stdio.h&gt
int main(){
    int a = 5;
    int b = 10;
    int* p_a = 0;
    p_a = &a;
    b = *p_a;
}
</code></pre>
<p>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    <table class="table">
      <thead>
        <tr>
          <th scope="col">Address</th>
          <th scope="col">Value</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1600</th>
          <td><code>5</code> (<code>a</code> of type <code>int</code>)</td>
        </tr>
        <tr>
          <th scope="row">1632</th>
          <td><code>5</code> (<code>b</code> of type <code>int</code>)</td>
        </tr>
        <tr>
          <th scope="row">1664</th>
          <td><code>1600</code> (<code>p_a</code> of type <code>int*</code></td>
        </tr>
        <tr>
          <th scope="row">1696</th>
          <td></td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

</div>
</div>
Note that in the above example, not every address was written down. In C, every address is a byte. We can use the <code>sizeof</code> operator, which gives the size of an object. For example, <code>sizeof(int)</code> gives the size of an int and <code>sizeof(a)</code> gives the size of the variable <code>a</code>. The output is represented in bits. We can print this to console using<code>printf("%ud", sizeof(int))</code>
<h2 id="L4-strings">Strings</h2>
Recall that each character will always be 1 byte. The reason this is important is if we recall strings can be defined using a <i>pointer,</i><br><br>
<pre><code class="language-C">char *s = "xyz"</code></pre>
we get a memory table that looks like,<br><br>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1824</th>
      <td><code>'x'</code></td>
    </tr>
    <tr>
      <th scope="row">1832</th>
      <td><code>'y'</code></td>
    </tr>
    <tr>
      <th scope="row">1840</th>
      <td><code>'z'</code></td>
    </tr>
    <tr>
      <th scope="row">1848</th>
      <td><code>\0</code></td>
    </tr>
    <tr>
      <th scope="row">1856</th>
      <td><code>1824</code> (<code>s</code> of type "address of char")</td>
    </tr>
  </tbody>
</table>
A few key observations:
<ul>
  <li>Each address can hold 1 byte and each character is 1 byte. Perfect!</li>
  <li>The null character <code>\0</code> signifies the end of the string, so that we know when to stop. This is important, because we don't store the length anywhere!</li>
  <li>The variable <code>s</code> gets stored elsewhere and is equal to the address of the first character.</li>
  <li>We are specifying that the addresses are part of the main locals frame. This is important in the next subsection where we will be also working with the locals frame of a particular function.</li>
</ul>
We can treat <code>s</code> as just any other variable! For example,<br><br>
<pre><code class="language-C">printf("%c", *s);</code></pre>
will print out <code>'x'</code>, and<br><br>
<pre><code class="language-C">printf("%ld", (long int)s);</code></pre>
will print <code>'1824'</code>.

<h2 id="L4-functions">Changing Variables in Functions</h2>
Suppose we have the following naive attempt at changing a variable through a function. We have,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
void f(int a) // NOTE: INCORRECT
{
  a = 12;
}

int main()
{
  int a = 5;
  f(a);
  printf("%d", a);
}
</code></pre>
When the function is run, a locals frame for the function will be created, so after the line <code>a=12;</code> is run, the memory table looks like this:
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [f]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">128</th>
      <td><code>12</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">160</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">192</th>
      <td></td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1600</th>
      <td><code>5</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">1632</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">1664</th>
      <td></td>
    </tr>
  </tbody>
</table>
Therefore, when variables are defined inside a function, they are stored in a different locals frame. When we exit the function, we no longer get access to inside the function locals frame and the original value of <code>a</code> is unchanged.
<br><br>
So how do we fix this?
<br><br>
The standard solution is to instead pass the value of <code>a</code> (or else the function will just create a copy of it), we pass in the address <code>&a</code>. The function does not need to change what this address is, but it can read off this value and go to the proper location in memory and modify it. The correct implementation is<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
void f(int* p_a)
{
  *p_a = 12;
}

int main()
{
  int a = 5;
  f(&a);
  printf("%d", a);
}</code></pre>
The parameter that the function takes in is of type <code>int*</code> so we need to send in an address. Inside the function, the line <code>*p_a = 12;</code> tells us to go to the address given by <code>p_a</code> (via the dereference operator <code>*</code>) and assign the value <code>12</code> to it. The memory table then looks like
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [f]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">128</th>
      <td><code>1600</code> (<code>p_a</code> of type <code>int*</code>)</td>
    </tr>
    <tr>
      <th scope="row">160</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">192</th>
      <td></td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1600</th>
      <td><code>12</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">1632</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">1664</th>
      <td></td>
    </tr>
  </tbody>
</table>
How does this relate to Python? If we consider the code<br><br>
<pre><code class="language-py">def f(a):
  a = 12
def main():
  a = 5
  f(a)
</code></pre>
then the same thing happens in C. The value of <code>a</code> remains unchanged. However, lists are mutable and can be changed inside a function. Consider<br><br>
<pre><code class="language-py">def f(L):
  L[0] = 12
def main():
  L = [5, 6]
  g(L)
</code></pre>
Then passing in the variable <code>L</code> means having the <code>L</code> in the function refer to the same address as the <code>L</code> defined in the main function. However in Python, most variables are immutable (integers, floats, strings, Booleans, and tuples), so we cannot change them by modifying their value at a certain address! To see this concretely, feel free to run:<br><br>
<pre><code class="language-py">a = 1
print(id(a)) # prints the address
a = 2
print(id(a)) # prints the address
</code></pre>
and see that the memory addresses are different, so behind the scenes, Python is writing <code>2</code> in a new space in memory and then associating the variable <code>a</code> with this new address.
<br><br>
Because C gives us more freedom to work directly with the memory, we can do much more powerful things and implement more complex data structures, as we will see in the coming weeks.
<br><br><br><br>
</div>
    </div>
  </body>
</html>
