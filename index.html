<!DOCTYPE html>
<html>
  <head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YCY17GV3DB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-YCY17GV3DB');
</script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="assets/favicon.png" />
    <title>ESC190 Lecture Notes</title>
    <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous"> -->

    <!-- Bootstrap Style -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />

    <!-- TOC CSS -->
    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/bootstrap-toc.css">

    <link rel="stylesheet" href="https://afeld.github.io/bootstrap-toc/assets/screen.css" media="screen" charset="utf-8">

    <script
      src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
      integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN"
      crossorigin="anonymous"
    ></script>

    <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
    crossorigin="anonymous"
  ></script>
  <script src="https://afeld.github.io/bootstrap-toc/bootstrap-toc.js"></script>
      
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script type="text/javascript">
  (function (i, s, o, g, r, a, m) {
    i["GoogleAnalyticsObject"] = r;
    (i[r] =
      i[r] ||
      function () {
        (i[r].q = i[r].q || []).push(arguments);
      }),
      (i[r].l = 1 * new Date());
    (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
    a.async = 1;
    a.src = g;
    m.parentNode.insertBefore(a, m);
  })(
    window,
    document,
    "script",
    "//www.google-analytics.com/analytics.js",
    "ga"
  );

  ga("create", "UA-19048260-11", "auto");
  ga("send", "pageview");

  hljs.highlightAll();
</script>
</head>
<body data-bs-spy="scroll" data-target="#toc">
  <div class="container">
    <div class="row">
      <div class="col-sm-3">
        <nav id="toc" data-toggle="toc" class="sticky-top"></nav>
      </div>
      <div class="col-sm-9">


<h1 id="-esc190-lecture-notes">ESC190 Lecture Notes</h1>
    <p>These are official course notes for ESC190: Computer Algorithms and Data Structures.
      <br><br>
      I will do my best to update notes within 24 hours of the lecture recording being posted. If you have any feedback, questions, clarifications, or if you see a typo or a mistake, feel free to email me at <a href="mailto:qilin.xue@mail.utoronto.ca">qilin.xue@mail.utoronto.ca</a>.
      <br><br>
      Cheers!<br>
      QiLin
    </p>
<h1 id="L2">L2: Introduction to C, pointers and dereferencing</h1>
<h2 id="L2-syntax">Variables</h2>
Like Python, there are different types of variables. Unlike Python, you need to declare what type it is when you initialize. After initializing, we can only change this variable to another value of the same type.
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
    int a = 42; // Need to initialize the type of variable
    a = 43; // Changing the value of an already initialized variable
    // a = "hi"; will give an error or warning!

    printf("%d\n", a); // Prints 43

    return 0;
}
</code></pre>
Why does C do this? Because compiler needs to assign the appropriate space in the memory table. Therefore, we need to think of variables in a slightly different way. When the code initializes, it stores 42 in memory, i.e. at address 3040 (nothing inherently special about this number, only here so we have a concrete example). <b>The program associates <code>a</code> with this address.</b> The table becomes,<br><br>
<table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>42</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  After the line <code>a = 43;</code> is run, the program will look at the address in which the value of <code>a</code> is stored, and change that value to 43. The table then changes to,<br><br>
  <table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>43</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td></td>
      </tr>
    </tbody>
  </table>
 Note that this is not how Python works. Changing the value of a variable will change the address of that variable. C is therefore <i>more</i> intuitive in the sense that variables are associated with a location in physical memory.
 
 Finally, the line <code>printf("%d\n",a)</code> tells us to print the value of <code>a</code>. The format specifier <code>%d</code> tells the program to interpret <code>a</code> as an integer, and <code>\n</code> tells the code to make a line break. Here is a list of <a href="https://www.tutorialspoint.com/format-specifiers-in-c">format specifiers.</a>
 <h2 id="L2-pointers">Pointers</h2>
 We can store the address of variables using <i>pointers.</i> To create a variable <code>p_a</code> that can store the address of another variable, we use the <code>int*</code> type. The operator <code>&</code> retrieves the address of a given variable.
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
    int a = 42;
    int* p_a = &a; // & is the "address-of" operator
                   // int* is the type "address of int"
    printf("%ld\n", p_a); // %ld specifies a long integer
    return 0;
}</code></pre>
In the above code, <code>p_a</code> stores the address of <code>a</code>, which if we continue to use our earlier memory table, is equal to 3040. We can print the pointer using the type specifier <code>%ld</code>, as pointers are stored as long integers (which takes twice as more bits than regular integers).<br><br>

Typically, long integers are 64 bits on most systems and integers are 32 bits. If you haven't noticed, this is why the addresses in our example tables go up by 32! (to make visualization easier)<br><br>

The above code may give a warning (depends on system) that the formats that <code>%ld</code> expects and the variable given don't match, as <code>p_a</code> technically has type <code>int*</code>. However, because we can represent <code>p_a</code> as a long integer, we can cast it by running <code class="language-C">printf("%ld\n", (long int)p_a);</code> instead.

<h2>Dereferencing Operator</h2>
The dereferencing operator is given by <code>*</code> and acts on a memory address to get the value stored in memory at that address. For example, the code <code class="language-C">int value_of_a = *p_a;</code> tells us the program to get the value of <code>p_a</code> which is an address, then go to that address, and retrieve the value stored there. Suppose we run the code
<pre><code class="language-C">#include &lt;stdio.h&gt
    int main()
{
        int a = 42;
        int* p_a = &a;
        int b = *p_a; 
        return 0;
    }</code></pre> we get the following memory table:<br><br>
  <table class="table">
    <thead>
      <tr>
        <th scope="col">Address</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">3040</th>
        <td><code>43</code> (<code>a</code> of type <code>int</code>)</td>
      </tr>
      <tr>
        <th scope="row">3072</th>
        <td><code>3040</code> (<code>p_a</code> of type <code>int*</code>)</td>
      </tr>
      <tr>
        <th scope="row">3104</th>
        <td>(space taken up by above)</td>
      </tr>
      <tr>
        <th scope="row">3136</th>
        <td><code>43</code> (<code>b</code> of type <code>int</code>)</td>
      </tr>
    </tbody>
  </table> The symbol <code>*</code> is used both to define variables (i.e. as a type) and also as an operator for dereferencing. While both are used in the context of memory, they are separate.

  You may notice that the variable <code>p_a</code> takes up 64 bits instead of the standard 32 bits. This is because addresses are usually stored as long integers by most systems.
<h2 id="L2-functions">Functions</h2>
Functions generally work mostly the same way as Python. It is important to note that when an input is passed to the function, the function makes a copy of it in the sense that it uses a different locals frame. For example,
<pre><code class="language-C">#include &lt;stdio.h&gt
    int f(int x){
        return x + 1;
    }
    int main()
{
        int a = 42;
        int* p_a = &a;
        int b = *p_a; 

        int c = f(b);
        return 0;
    }</code></pre>
    which gives the additional memory table,<br><br>
    <table class="table">
        <thead>
          <tr>
            <th scope="col">Address</th>
            <th scope="col">Value</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th scope="row">1280</th>
            <td><code>5</code> (<code>x</code> of type <code>int</code>)</td>
          </tr>
          <tr>
            <th scope="row">1312</th>
            <td></td>
          </tr>
          <tr>
            <th scope="row">1344</th>
            <td></td>
          </tr>
          <tr>
            <th scope="row">1376</th>
            <td></td>
          </tr>
        </tbody>
      </table>
      Therefore, if we were to change the value of <code>x</code> inside the function, it would only affect the value at address 1280, and the value of <code>b</code> (from the main memory table) will not be affected. 

<h1 id="L3">L3: Binary representation of ints, floats, and strings</h1>
At a fundamental level, computer memory can be seen as a physical table where in each cell, the voltage is either high (1) or low (0). It does not know anything about types. A single <code>0</code> or <code>1</code> is a bit, and 
<ul>
    <li>8 bits = byte</li>
    <li>kilobyte = 1024 bytes</li>
    <li>megabyte = 1000 kilobytes</li>
</ul>
The memory table stores a lot of information, including metadata. You will learn more about this in courses such as ECE253 and higher level 300+ courses. In this course, we will only deal with memory tables in the context of storing variables.
<h2 id="L4-binary">Binary</h2>
We can interpret the binary number \(1101\) as 
\[1101_\text{binary} = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0 = 13.\]
Remark: that this is also exactly how decimals work! Also,
\[521 = 5\cdot 10^2 + 2 \cdot 10^1 + 1 \cdot 10^0.\]
It is less obvious how to go from decimal to binary. Suppose we want to convert \(25\) to binary.
<ul>
    <li>Right-to-left:</li>
    <ol>
        <li>25 is odd, so last digit in binary is \(1\). We now have to represent (25-1)/2 = 12.</li>
        <li>12 is even, so 2nd last digit in binary is \(0\). We now have to represent (12-0)/12 = 6.</li>
        <li>6 is even, so 3rd last digit in binary is \(0\). We now have to represent (6-0)/12 = 3.</li>
        <li>3 is odd, so 4th last digit in binary is \(1\). We now have to represent (3-1)/2 = 1.</li>
        <li>We can represent 1 by \(1\).</li>
    </ol>
    which gives 
    \[11001\]
    A Python implementation is given below
    <iframe src="https://trinket.io/embed/python3/7b7fd3c0aa" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>
    <li>Left-to-right:</li>
    <ul>

    <li>
        The idea is that we want to write 25 as 
        \[25 = b_k2^k +b_{k-1}2^{k-1} + \cdots + b_12^1 + b_0\]
        Are we able to figure out what \(k\) is? We can determine the <i>largest power of 2 that fits into 25,</i> which is \(2^4=16\). We still need to represent \(25-16=9\)
    </li>
    <li>
        The largest power of 2 that can fit in 9 is \(2^3=8\). We then need to represent \(9-8=1\)
    </li>
    <li>
        The largest power of 2 that can fit in 1 is \(2^0=1\). We are now done.
    </li>
    We have decomposed \(25\) into powers of 2. That is,
    \[25 = 2^4 + 2^3 + 2^0 = 11001_\text{binary}.\]
    </ul>
</ul>
For 8-bit binary numbers, the 0th digit is the sign and the other 7 bits are the quantity. For example,
\[
b_0b_1b_2b_3b_4b_5b_6b_7 = \begin{cases}
+(b_12^6 + b_22^5 + b_32^4+b_42^3 + b_52^2 + b_62^1 + b_7) & \text{if }b_0 = 0 \\
-(b_12^6 + b_22^5 + b_32^4+b_42^3 + b_52^2 + b_62^1 + b_7) & \text{if }b_0 = 1
\end{cases}
\]
This is not the only way to represent numbers. Different schemes exist for different types, though there are some standard conventions (i.e. IEEE 754 for floats).

In Unicode, the first bit tells us whether we use ASCII characters (which we will use) or Unicode (which is more complicated).
<h2 id="L3-characters">Characters and Strings</h2>
The above discussion helps us understand how characters and strings are stored and worked with in C.  Consider the following program,
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
    char c = 'x';
    printf("%c %d", c, (int)c);

    return 0;
}</code></pre>
Notice that the program outputs <code>x 120</code>. This is because we can interpret <code>c</code> as a character, so it outputs <code>'x'</code>. Alternatively, we can interpret it as an integer, in which case it outputs its ASCII value <code>120</code>.

We can store strings by writing
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
    char* s = "Hello, World!";
    return 0;
}</code></pre>
where <code>s</code> is the address of the first character in the string (in this case, the address of 'H'). The last character in the string is <code>\0</code> (can otherwise write it as <code>0</code> or <code>NULL</code>). Therefore, the program is able to read off a string by going to the address of the first character, and moving down the table (which is where the other characters are stored) until the null character is found. Explicitly, this is stored in the memory table as (only showing part of the table)
<table class="table">
    <tbody>
      <tr>
        <th scope="row">16</th>
        <td><code>'H'</code></td>
      </tr>
      <tr>
        <th scope="row">17</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">18</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">19</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">20</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">21</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">22</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">23</th>
        <td>.</td>
      </tr>
    </tbody><tbody>
      <tr>
        <th scope="row"></th>
        <td></td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row">24</th>
        <td><code>'e'</code></td>
      </tr>
      <tr>
        <th scope="row">25</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">26</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">27</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">28</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">29</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">30</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">31</th>
        <td>.</td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row"></th>
        <td></td>
      </tr>
    </tbody>
    <tbody>
      <tr>
        <th scope="row">32</th>
        <td><code>'l'</code></td>
      </tr>
      <tr>
        <th scope="row">33</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">34</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">35</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">36</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">37</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">38</th>
        <td>.</td>
      </tr>
      <tr>
        <th scope="row">39</th>
        <td>.</td>
      </tr>
    </tbody>
  </table>
  Here, the dot is used to denote that it takes 8 bits (1 byte) to store each character.

<h1 id="L4">L4: Strings and Changing Variables in Functions</h1>
<div class="card">
  <h2 class="card-header" id="L3-review">Warm Up Question</h5>
  <div class="card-body">
    Draw the corresponding memory table given the following program. Assume an integer takes up 4 bytes.

<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
    int a = 5;
    int b = 10;
    int* p_a = 0;
    p_a = &a;
    b = *p_a;
}
</code></pre>
<p>
  <a class="btn btn-primary" data-bs-toggle="collapse" href="#L3Example" role="button" aria-expanded="false" aria-controls="L3Example">
    Show Solution
  </a>
</p>
<div class="collapse" id="L3Example">
  <div class="card card-body">
    <table class="table">
      <thead>
        <tr>
          <th scope="col">Address</th>
          <th scope="col">Value</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th scope="row">1600</th>
          <td><code>5</code> (<code>a</code> of type <code>int</code>)</td>
        </tr>
        <tr>
          <th scope="row">1632</th>
          <td><code>5</code> (<code>b</code> of type <code>int</code>)</td>
        </tr>
        <tr>
          <th scope="row">1664</th>
          <td><code>1600</code> (<code>p_a</code> of type <code>int*</code></td>
        </tr>
        <tr>
          <th scope="row">1696</th>
          <td></td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

</div>
</div>
Note that in the above example, not every address was written down. In C, every address is a byte. We can use the <code>sizeof</code> operator, which gives the size of an object. For example, <code>sizeof(int)</code> gives the size of an int and <code>sizeof(a)</code> gives the size of the variable <code>a</code>. The output is represented in bits. We can print this to console using <code>printf("%ud", sizeof(int))</code>.<br><br>

Depending on your system, you may get a warning in the above print statements. This is because <code>sizeof</code> returns a <code>size_t</code> type, that could either be an unsigned integer or an unsigned long integer (depending on your system). You may choose to use <code>%lu</code> or <code>%zu</code> instead.
<h2 id="L4-strings">Strings</h2>
Recall that each character will always be 1 byte. The reason this is important is if we recall strings can be defined using a <i>pointer,</i><br><br>
<pre><code class="language-C">char *s = "xyz"</code></pre>
we get a memory table that looks like,<br><br>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Memory</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1824</th>
      <td><code>'x'</code></td>
    </tr>
    <tr>
      <th scope="row">1832</th>
      <td><code>'y'</code></td>
    </tr>
    <tr>
      <th scope="row">1840</th>
      <td><code>'z'</code></td>
    </tr>
    <tr>
      <th scope="row">1848</th>
      <td><code>\0</code></td>
    </tr>
    <tr>
      <th scope="row">1856</th>
      <td><code>1824</code> (<code>s</code> of type "address of char")</td>
    </tr>
  </tbody>
</table>
A few key observations:
<ul>
  <li>Each address can hold 1 byte and each character is 1 byte. Perfect!</li>
  <li>The null character <code>\0</code> signifies the end of the string, so that we know when to stop. This is important, because we don't store the length anywhere!</li>
  <li>We are using double quotes here. Double quotes automatically include the null character at the end.</li>
  <li>The variable <code>s</code> gets stored elsewhere and is equal to the address of the first character.</li>
  <li>The variable is placed somewhere in memory that is generally <i>not</i> the locals frame. However, most variables are typically stored in the main locals frame. This will be important in the next subsection where we will be also working with the locals frame of a particular function.</li>
</ul>
We can treat <code>s</code> as just any other variable! For example,<br><br>
<pre><code class="language-C">printf("%c", *s);</code></pre>
will print out <code>'x'</code>, and<br><br>
<pre><code class="language-C">printf("%ld", (long int)s);</code></pre>
will print <code>'1824'</code>.

<h2 id="L4-functions">Changing Variables in Functions</h2>
Suppose we have the following naive attempt at changing a variable through a function. We have,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
void f(int a) // NOTE: INCORRECT
{
  a = 12;
}

int main()
{
  int a = 5;
  f(a);
  printf("%d", a);
}
</code></pre>
When the function is run, a locals frame for the function will be created, so after the line <code>a=12;</code> is run, the memory table looks like this:
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [f]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">128</th>
      <td><code>12</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">160</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">192</th>
      <td></td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1600</th>
      <td><code>5</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">1632</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">1664</th>
      <td></td>
    </tr>
  </tbody>
</table>
Therefore, when variables are defined inside a function, they are stored in a different locals frame. When we exit the function, we no longer get access to inside the function locals frame and the original value of <code>a</code> is unchanged.
<br><br>
So how do we fix this?
<br><br>
The standard solution is to instead pass the value of <code>a</code> (or else the function will just create a copy of it), we pass in the address <code>&a</code>. The function does not need to change what this address is, but it can read off this value and go to the proper location in memory and modify it. The correct implementation is<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
void f(int* p_a)
{
  *p_a = 12;
}

int main()
{
  int a = 5;
  f(&a);
  printf("%d", a);
}</code></pre>
The parameter that the function takes in is of type <code>int*</code> so we need to send in an address. Inside the function, the line <code>*p_a = 12;</code> tells us to go to the address given by <code>p_a</code> (via the dereference operator <code>*</code>) and assign the value <code>12</code> to it. The memory table then looks like
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [f]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">128</th>
      <td><code>1600</code> (<code>p_a</code> of type <code>int*</code>)</td>
    </tr>
    <tr>
      <th scope="row">160</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">192</th>
      <td></td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1600</th>
      <td><code>12</code> (<code>a</code> of type <code>int</code>)</td>
    </tr>
    <tr>
      <th scope="row">1632</th>
      <td></td>
    </tr>
    <tr>
      <th scope="row">1664</th>
      <td></td>
    </tr>
  </tbody>
</table>
How does this relate to Python? If we consider the code<br><br>
<pre><code class="language-py">def f(a):
  a = 12
def main():
  a = 5
  f(a)
</code></pre>
then the same thing happens in C. The value of <code>a</code> remains unchanged. However, lists are mutable and can be changed inside a function. Consider<br><br>
<pre><code class="language-py">def f(L):
  L[0] = 12
def main():
  L = [5, 6]
  g(L)
</code></pre>
Then passing in the variable <code>L</code> means having the <code>L</code> in the function refer to the same address as the <code>L</code> defined in the main function. However in Python, most variables are immutable (integers, floats, strings, Booleans, and tuples), so we cannot change them by modifying their value at a certain address! To see this concretely, feel free to run:<br><br>
<pre><code class="language-py">a = 1
print(id(a)) # prints the address
a = 2
print(id(a)) # prints the address
</code></pre>
and see that the memory addresses are different, so behind the scenes, Python is writing <code>2</code> in a new space in memory and then associating the variable <code>a</code> with this new address.
<br><br>
Because C gives us more freedom to work directly with the memory, we can do much more powerful things and implement more complex data structures, as we will see in the coming weeks.
<h1 id="L5">L5: Arrays and Pointer Arithmetic</h1>
<div class="card border-primary mb-3">
  <div class="card-header">Note on Convention</div>
  <div class="card-body text-primary">
    <h5 class="card-title">Pointers</h5>
    <p class="card-text">
      In earlier lecture notes, I wrote pointers as
    <pre><code class="language-C">int* p_a = &a;</code></pre>
      to emphasize that the variable is <code>a</code> and the type is <code>int*</code>. However, it is standard practice (and what the original creators of C used) to write
      <pre><code class="language-C">int *p_a = &a;</code></pre>
      Functionally, there is no difference. This is primarily a stylistic choice. Remember that the variable in question is still <code>a</code>.
    </p>
  </div>
</div>
<h2 id="L5-swap">Swapping two integers</h2>
<b>Problem:</b> Write a function to swap two integers.<br><br>

Similar to the problem of changing the value of a variable, we need to pass in the address of two variables instead of the values. This tells the function where in the memory table to look in order to swap the two integers. We have,
<pre><code class="language-C">#include &lt;stdio.h&gt
void swap(int *p_a, int *p_b)
{
  int temp = *p_a; // Create a temp variable in the function's local frame
  *p_a = *p_b;
  *p_b = temp;
}

int main()
{
  int x = 7;
  int y = 8;
  swap(&x, &y);

  return 0;
}
</code></pre>
<h2 id="L5-pointer-arithmetic">Pointer Arithmetic</h2>
Recall that strings can be stored using pointers. For example, the code<br><br>
<pre><code class="language-C">char *str = "hello";
printf("%c\n", str[1]);</code></pre>
will print out <code>'e'</code>, as C will treat the variable <code>str</code> of type <code>char *</code> as an array. Behind the scenes, the code is performing pointer arithmetic. That is, the above is equivalent to:<br><br>
<pre><code class="language-C">char *str = "hello";
printf("%c\n", *(str + 1));</code></pre>
When we have multiple oeprations, we perform what is in the parentheses first (similar to BEDMAS). Therefore, this code tells us to get the value of <code>str</code>, which is the address that holds the character <code>'h'</code>, then increase it by 1 byte (which is the address that holds the next character, <code>'e'</code>). Finally, the dereferencing operator gets the value stored at the address <code>str + 1</code>.<br><br>

There is one subtlety here, which we will see in the next section.
<h2 id="L5-arrays">Arrays</h2>
An array is a block of memory containing a sequence of elements, of the same type. Arrays always have a pre-specified size. We can initialize an array using curly braces.<br><br>
<pre><code class="language-C">int arr[5] = {1,2,3,4,5};</code></pre>
This is unlike Python, where we do not need to specify a size, and arrays can dynamically change in size. If you are familiar with <code>numpy,</code> C arrays are much more similar to <code>numpy</code> arrays. We are allowed to retrieve and modify array elements,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
  int arr[5] = {1,2,3,4,5};
  printf("%d\n", arr[2]); // prints 3
  arr[2] = 6;

  printf("%ud, %ud\n", sizeof(arr), sizeof(arr[0])) // prints 20, 4
  printf("#of elements in arr is %d\n", sizeof(arr) / sizeof(arr[0]))
}
</code></pre>
The first three lines in the main function will create the following memory table, where we are assuming integers take 32 bits:
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">1600</th>
      <td><code>1</code> (<code>arr</code> of type <code>int</code>, size <code>5</code>)</td>
    </tr>
    <tr>
      <th scope="row">1632</th>
      <td><code>2</code></td>
    </tr>
    <tr>
      <th scope="row">1664</th>
      <td><code>3</code></td>
    </tr>
    <tr>
      <th scope="row">1696</th>
      <td><code>4</code></td>
    </tr>
    <tr>
      <th scope="row">1728</th>
      <td><code>5</code></td>
    </tr>
  </tbody>
</table>
The <code>sizeof</code> operator gives how much space the variable takes up, in bytes. This means that <code>sizeof(arr[0])</code> will give 4 bytes, since <code>arr[0]</code> is an integer and <code>sizeof(arr)</code> will give 20 bytes, since 20 = 4 x 5, where 5 is the number of elements.<br><br>

When passing an array to a function, it gets converted to a pointer. For example, if we have the function<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
void set0(int *p_a)
{
  *p_a = 0; // p[0] = 0;
  printf("%ud\n", sizeof(p_a)); // prints 8
}
int main()
{
printf("%ud", 3);
  int arr[5] = {1,2,3,4,5};
  printf("%d\n",arr[0]); // prints 1
  set0(arr);
  printf("%d\n",arr[0]); // prints 0
}
</code></pre>
Because arrays get converted to pointers, calling <code>sizeof</code> inside the function gives us the length of the pointer, which is 8 bytes. This is why when writing functions that deal with arrays, we typically need to pass in another parameter so the function will know how long the array is.<br><br>

Because arrays are so similar to pointers, we can treat them as pointers when performing operations. For example, <code>arr[2] = 6;</code> is the same as <code>*(arr + 2) = 6;</code><br><br>

There is one slight caveat here to any eagle-eyed student! When we worked with strings, <code>str + 2</code> added 2 bytes to the pointer. Here however, <code>arr + 2</code> added 2 x 4 = 8 bytes to the pointer! Therefore, <i>pointer arithmetic is conscious of the type of the pointer.</i><br><br>

Therefore, <code>*(arr+i)</code> and <code>arr[i]</code> will always be equivalent.
<h2 id="L5-strings">Revisiting Strings</h2>
We can initialize strings the same way we initialize arrays because of how similar they are. The following are equivalent:
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
  char arr1[4] = "uvw";
  char arr2[4] = {'x', 'y', 'z', '\0'};
  char arr3[3] = {'a', 'b', 'c'}; // Incorrect, will produce weird results
  printf("%s\n", arr1); // uvw
  printf("%s\n", arr2); // xyz
  printf("%s\n", arr3); // something weird!
}
</code></pre>
Some key points:
<ol>
  <li>The size of the array should be set to 1 more than the number of characters. This is because strings always end with the null character <code>\0</code>.</li>
  <li>The null character is automatically included when we define a string by concatenating characters, i.e. like in the definition of <code>arr1</code>.</li>
  <li>If we forget to include the null character when defining it explicitly as an array, i.e. for <code>arr3</code>, then the program doesn't know when to stop. When printing (and other operations), it will only stop once it reaches a null character. On my machine, the output was <code>abcuvw</code>.</li>
</ol>
Alternatively, we can define arrays (and strings) without specifying a size via:<br><br>
<pre><code class="language-C">char arr[] = {'x', 'y', 'z', '\0'};</code></pre>
The program will automatically determine how many entries this array has.<br><br>
<h2 id="L5-arrays-in-functions">Arrays in Functions</h2>
Initializing arrays inside functions is similar to initializing an integer inside a function, except we now allocate a block of memory. Here is incorrect code of how we can make an array.
<pre><code class="language-C">#include &lt;stdio.h&gt
int *make_array_wrong()
{
  int arr[5] = {1, 2, 3, 4, 5};
  return arr;
}</code></pre>
We must not access something like <code>arr[0]</code> outside the function. Accessing the actual address arr is not a problem, but <code>arr</code> is not anymore the address of anything in particular.<br><br>

To properly do this, we need to allocate a block of memory on the heap (as opposed to on the stack).
<ul>
  <li>Heap: The memory table in general that's not tied to the locals frame</li>
  <li>Stack: In the locals frame of the function</li>
</ul>
To do this, we can use the following notation:<br><br>
<pre><code class="language-C">int *a = (int *)malloc(sizeof(int) * 12);</code></pre>
where <code>a</code> is now a pointer to a block of memory of size <code>12 * sizeof(int)</code> bytes. This is enough space for 12 integers. Note that we need to cast the pointer to an integer pointer using <code>(int *)</code>, since <code>malloc</code> returns a void pointer (i.e. it just knows to create this much space in the memory table, but doesn't know what this space is used for). To create an array inside a function, we can use the following code,<br><br>
<pre><code>#include &lt;stdio.h&gt
#include &lt;stdlib.h&gt

int *make_array_right()
{
    int *a = (int *)malloc(5*sizeof(int));
    a[0] = 1;
    a[1] = 2;
    a[2] = 3;
    a[3] = 4;
    a[4] = 5;

    return a;
}
int main()
{
  int *a_good = make_array_right();
  printf("%d" , a_good[0]);

  free(a_good);
}
</code></pre>
To use <code>malloc()</code> we need to use the <code>stdlib.h</code> library (standard library). In the above code, <code>a</code> is a local variable, but it refers to a place in memory that doesn't go away, so we can still refer to it outside the function.<br><br>

It is also important to free the memory when we no longer need the variable. This is because not using <code>free()</code> could result in a memory leak, i.e. blocks of memory are no longer needed but the computer still thinks are in use. Once the memory block is freed accessing it is undefined behavior.
<br><br><br><br>
<h1 id="L6">L6: More on Strings and Double Pointers</h1>
<h2 id="L6-Changing-Strings">Editing Strings</h2>
Recall that we can define strings in two ways. Both ways are similar, but there are key differences that are very important. Consider,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
  // Defining string using address of character
  char *str = "abc";
  // not allowed to go str[1] = 'x';
  printf("%c\n", str[1]); // allowed to print str[1]
  printf("%zu\n", sizeof(str)); // 8 (since pointers are long ints)

  // Defining string using array
  char str2[] = "abc"; // alternatively char str2[] = {'a','b','c','\0'};
  str2[0] = 'x'; // fine
  printf("%s\n", str2); // xbc
  printf("%zu\n", sizeof(str2)); // 4 ({'a','b','c','\0'} takes up 4 bytes)
}</code></pre>
The main difference is that when we are defining the string using the first method, the string is placed somewhere in memory that is generally not the locals frame and thus we are not allowed to change it, only read it. But defining it as an array does place it in the main locals frame, and thus we can change it like a regular array.<br><br>

Because one is an array and the other is an address, their sizes are different as well. We can also define strings a third way, using <code>malloc</code>, which was briefly touched upon last lecture. We can have,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
  char *str = (char *)malloc(3*sizeof(char)); // same as malloc(3)
  str3[0] = 'b';
  str3[1] = '\0';
  printf("%s\n", str3); // b
  free(str); // frees memory
}</code></pre>
which will produce the following memory table,
<table class="table">
    <thead>
      <tr>
        <th scope="col">Locals Frame [main]</th>
        <th scope="col">Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <th scope="row">32</th>
        <td><code>3200</code> (<code>str5</code> of type <code>int *</code>)</td>
      </tr>
      <tr>
        <th scope="row">64</th>
        <td></td>
      </tr>
      <tr>
        <th scope="row">96</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  <table class="table">
    <tbody>
      <tr>
        <th scope="row">3200</th>
        <td><code>'b''</code></td>
      </tr>
      <tr>
        <th scope="row">3201</th>
        <td><code>'\0'</code></td>
      </tr>
      <tr>
        <th scope="row">3202</th>
        <td></td>
      </tr>
    </tbody>
  </table>
  Remember that it is always best practice to free variables once they are no longer needed.
<h2 id="L6-String-Functions">String in Functions</h2>
Similar to arrays, we cannot create strings inside a function and return the address of the local variable. Consider the following code,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
char *make_string_wrong(int sz)
{
  char str[sz];
  return str;
}
int main()
{
  char *str = make_string_wrong(3);
  str[0]; // not allowed , might crash
  printf("%ud\n", str); // fine, prints the address where str used to be 
}</code></pre>
Instead, we need to use <code>malloc</code> again. The following code works,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
char *make_string_right(int sz)
{
  char *str = (char *)malloc(sz*sizeof(char));
  return str;
}
int main()
{
  char *str = make_string_right(3);
  str[0]; // allowed
  printf("%lu\n", (long int)str); // 94182356746912 when I ran it
}</code></pre>
<h2 id="L6-Double-Pointers">Double Pointers</h2>
Consider the following code,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
int main()
{
  int *a = 0;
  int **p_a = &a;

  &a; // 3032
  *p_a // 0;
  *(&a) // a;
  &(0) // makes no sense
}</code></pre>
This looks like a mess, but we can look at the memory table.
<table class="table">
  <thead>
    <tr>
      <th scope="col">Locals Frame [main]</th>
      <th scope="col">Value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">3032</th>
      <td><code>0</code> (<code>a</code> of type <code>int *</code>)</td>
    </tr>
    <tr>
      <th scope="row">3064</th>
      <td>(space used by above)</td>
    </tr>
    <tr>
      <th scope="row">3092</th>
      <td><code>3032</code> (<code>p_a</code> of type <code>int **</code>)</td>
    </tr>
    <tr>
      <th scope="row">3124</th>
      <td>(space used by above)</td>
    </tr>
  </tbody>
</table>
and we can work through the above computations:
<ol>
  <li><code>&a</code> gives 3032, since that is the address of where <code>a</code> lives</li>
  <li><code>*p_a</code> gives 0, since it takes the value of <code>p_a</code> (which is 3032), and it looks at which value lives at that address, which happens to be 0.</li>
  <li><code>*(&a)</code> will always give <code>a</code> since it first determines the address of <code>a</code> and then the dereference operator tells the program to go to the value stored at that address, which is <code>a</code>.</li>
  <li><code>&(0)</code> makes no sense since we cannot take the address of a value that is not a variable.</li>
  </ol>

<h1 id="L7-Strings">L7: More Memory and String Operations</h1>
<h2 id="L7-initializing-pointers">Initializing Pointers</h2>
Consider the following code, which initializes a pointer in three different ways:<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
#include &lt;stdlib.h&gt

int main()
{
  int *p_a = 0; // p_a is an address of an integer
                // 0 is not a valid address 
  printf("%d\n", *p_a); // error

  // METHOD 1: Use Malloc
  p_a = (int *)malloc(sizeof(int));
  printf("%d\n", *p_a); // not error, but value can be anything
  *p_a = 42; // p_a[0] = 42
  printf("%d\n", *p_a); // 42
  free(p_a) // Need to free, see comments!

  // METHOD 2: Assign it using the address
  int b = 43;
  p_a = &b;
  printf("%d\n", *p_a); // 43

  // METHOD 3: Using arrays
  int c[] = {5, 8, 10};
  p_a = c;
  p_a[0]; // 5

  p_a++; // p_a = p_a + 1
  p_a[0]; // 8
}</code></pre>
Some comments about the above code:
<ol>
  <li>Initializing a pointer like <code>int *p_a = 0;</code> is a common thing to do, but we can't do anything since <code>0</code> is not a valid address</li>
  <li>Instead, we can use <code>malloc</code> to free up space in memory and store that address in <code>p_a</code></li>
  <li>If we later store a different address in <code>p_a</code> (without freeing first), then the address of the memory allocated by <code>malloc</code> will be lost, which can lead to memory leaks.</li>
  <li>To prevent memory leaks, we need to free the memory before reassigning it. If <code>free(p_a)</code> at the very end of the program, it will cause a crash because it will attempt to free the memory at the address <code>&b</code> instead, which wasn't created using <code>malloc</code>.</li>
  <li>If we tried to run <code>p_a++;</code> after the <code>malloc</code> instead, it will crash, since we only allocated enough memory for a single integer.</li>
</ol>
We can initialize double pointers the same way,<br><br>
<pre><code class="language-C">#include &lt;stdio.h&gt
#include &lt;stdlib.h&gt

int main()
{
  int **p_p_a = 0;
  // accessing *p_p_a here gives an error
  p_p_a = (int **)malloc(sizeof(int *));
  // p_p_a is valid address, so we can access *p_p_a;
  *p_p_a = (int *)malloc(sizeof(int));
  **p_p_a = 58; 
}</code></pre>
<h2 id="L7-strings">String Operations</h2>
Consider the following function to print an array:<br><br>
<pre><code class="language-C">void print_array(int *arr, int sz)
{
  int i;
  for (i = 0; i &lt; sz; i++)
  {
    printf("%d ", arr[i]);
  }
  printf("\n");
}</code></pre>
We can write something similar to print a string manually,
<pre><code class="language-C">void manual_print_str(char *str)
{
  int i = 0;
  while(str[i] != '\0'){
    printf("%c", str[i]);
    i++;
  }
  printf("\n");

  /*
  // Also Valid
  for(i = 0; str[i] != '\0', i++){
    printf("%c", str[i]);
  }
  */
}
</code></pre>
The key difference is that we don't need to pass the size of the string. We can tell when to stop when we reach the null character <code>'\0'</code>. An alternative way is via pointer arithmetic,<br><br>
<pre><code class="language-C">void print_str(char *str)
{
  while(*str != '\0'){
  // while(*str) works too
    printf("%c", *str);
    str++;
  }
  printf("\n");
}</code></pre>
We can simplify our code by saying<code>while(*str)</code> instead, which works since <code>*str</code> evaluates to <code>true</code> whenever it is not null We can also determine the length of a string in similar ways,<pre><code class="language-C">int manual_strlen(char *str)
{
  int i = 0;
  while(str[i] != '\0'){
    i++;
  }
  return i;
}</code></pre>
or if you want to show off,<br><br>
<pre><code class="language-C">int strlen(char *str)
{
  int length = 0;
  while(*str++){
    length++;
  }
}</code></pre>
Here, <code>*str++</code> means first access <code>*str</code> then increment <str>str</str>. Here is a list of common shortcuts:
<ol>
  <li><code>str++</code> puts <code>str + 1</code> into <code>str</code>, the value of <code>*str</code> is <code>str[0]</code></li>
  <li><code>*++a</code> means first increment <code>a</code> then access <code>*a</code></li>
  <li><code>a++ = a + 1</code> is undefined behaviour</li>
</ol>
<br><br><br><br><br>
</div>
    </div>
  </body>
</html>
